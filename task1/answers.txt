Часть 1

a) Начиная с N = 20 продолжайте увеличивать N с шагом 5 до тех пор, пока вычисление fib_p(N) будет занимать меньше пяти секунд. При каком N это условие перестает выполняться? Почему так происходит?

timer:tc(Module, Function, Arguments)

Время выполнения fib_p:
N = 20, Time = 1013
N = 25, Time = 9248
N = 30, Time = 80673
N = 35, Time = 895888
N = 40, Time = 9253793

Нелинейное увеличение времени выполнения при использовании fib_p(N) объясняется использованием обычной рекурсии, при которой при каждом рекурсивном вызове функции создается набор её параметров и локальных переменных, который вместе с адресом возврата размещается в стеке и хранится до тех пор, пока не будут разрешены все параметры и не будет совершен возврат из функции, что и приводит к увеличению времени работы и засорению памяти стека.

b) Сколько времени тратится на вычисление tail_fib(10000)? Почему?
С помощью функции tc/3 модуля timer, определяем, что на выполнение функция tail_fib(10000) тратиться порядка 4240 мкс. 

N = 10000, Time = 3712

Это объясняется тем, что данная функция использует хвостовую рекурсию, которая преобразует линейный процесс рекурсивного вызова в итеративный процесс. В этом случае сохранение контекста уже не имеет значения — ни параметры, ни локальные переменные уже использоваться не будут, а адрес возврата уже находится в стеке. Поэтому вместо полноценного рекурсивного вызова функции можно просто заменить значения параметров в стеке и передать управление на точку входа.

Часть 2
1> c(mobius).
{ok,mobius}
2> mobius:find_square_multiples(4, 30000).
242
3> mobius:find_square_multiples(5, 30000).
844
4> mobius:find_square_multiples(6, 30000).
22020
5> timer:tc(mobius, find_square_multiples, [4,30000]).
{1643,242}
6> timer:tc(mobius, find_square_multiples, [5,30000]).
{6867,844}
7> timer:tc(mobius, find_square_multiples, [6,30000]).
{189435,22020}

